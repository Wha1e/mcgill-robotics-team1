/******************************************************
SOURCE CODE FOR ARDUINO CONTROLLED FLAPPY BIRD PLAYER
Made for McGill Robotics Mini Projects Team 1
Tristan Struthers, U3 Software Engineering
Wen Bo Zhang, U3 Electrical Engineering
Ke Zhang, U1 Software Engineering
Amine Nouri, U2 Electrical Engineering
Hoyoung Kang, U1 Mechanical Engineering
Yasasa Abeysirigoonawardena, U0 Computer Engineering
Ananya Chandra, U0 Electrical Engineering
*******************************************************/


import java.util.LinkedList;
import cc.arduino.*;
import processing.serial.*;

// Global Variables
boolean started; // Sets game state
LinkedList<Pipe> pipes = new LinkedList<Pipe>();
Bird aBird = new Bird();
boolean recentlyJumped = false;
boolean userControlled = false; // Toggles software algorithm
int controlState = 2; // 
int flightState;
boolean hovering = true;
int lastHoverCall = 0;
Arduino arduino;
int servoPin = 9;

// Bird class, contains positional, velocity, and accelerational data.
class Bird{
  PVector location;
  PVector velocity;
  PVector acceleration;
  PVector jumpAccel;
  int topSpeed;
  
  
  Bird(){
    this.location = new PVector(150, height/2);
    this.velocity = new PVector(0, 0);
    this.acceleration = new PVector(0, 0.15);
    this.jumpAccel = new PVector(0, -0.5);
    this.topSpeed = 10;
  }
  
  void jump(){
    if( !recentlyJumped ){
      this.velocity.y = -3;
    }
    recentlyJumped = true;
  }
  
  void updateBird(){
    velocity.add(acceleration);
    if( this.velocity.y >= this.topSpeed ){
      this.velocity.y = this.topSpeed;
    }
    location.add(velocity);
  }
  void drawBird(){
    stroke(126);
    fill(126);
    ellipse(this.location.x, this.location.y, 30, 30);
  }
}

// Pipe class, contains data about the height and size of the gap, Gap variation is generated by perlin noise, in an attempt to get a navigateable
// maze, while still maintaining an element of randomness.
class Pipe{
  int xLoc;
  int gap;
  
  Pipe(){
    this.xLoc = 1000;
    float n = (noise(frameCount));
    this.gap = (int)map(n, 0, 1, 150, 550);
  }
  
  void updatePipe(){
      this.xLoc--;
  }
  
  void drawPipe(){
    // upper half
    stroke(126);
    fill(0);
    rect(xLoc, 0, 100, this.gap);
    
    // lower half
    stroke(126);
    fill(0);
    rect(xLoc, this.gap + 150, 100, height);
  }
}

// hover method, uses millis() to control the timing for the next tap
void hover(int timeCalled){
  if( hovering == false ){
    hovering = true;
    lastHoverCall = timeCalled;
  }
  int delay = (millis() - lastHoverCall) % 338 ;
  if( delay < 25 ){
    arduino.analogWrite(servoPin, 6);
  }else{
    arduino.analogWrite(servoPin, 0);
  }
}

void setup(){
  frameRate(120);
  size(1000, 700);
  background(255);
  flightState = 2;
  
  // Initialize a new arduino object for use with the firmata framework
  arduino = new Arduino(this, Arduino.list()[2], 57600);
  arduino.pinMode(servoPin, Arduino.OUTPUT);
  arduino.analogWrite(servoPin, 0);
}

void draw(){
  background(255);
  
  if( frameCount % 10 == 0 ){
    recentlyJumped = false;
  }
  
  // In the case !started, the game is waiting to be started
  if( !started ){
    aBird.drawBird();
    flightState = 2;
    if( keyPressed && key ==' ' ){
      started = true;
    }
  }
  // In the case that the game state is started, ie the game is being played
  else{
    Pipe aPipe;
    if( frameCount % 300 == 0 ){
      aPipe = new Pipe();
      pipes.addLast(aPipe);
    }
    
    if( aBird.location.y > height ){
      started = false;
      aBird = new Bird();
      pipes = new LinkedList<Pipe>();
    }
    
    // Collision detection for the bird and the pipes
    if( pipes.size() > 0 ){
      if( pipes.getFirst().xLoc < aBird.location.x + 13 && pipes.getFirst().xLoc + 100 > aBird.location.x - 13
        && (pipes.getFirst().gap > aBird.location.y - 13 || pipes.getFirst().gap + 150 < aBird.location.y + 13 ) ){
        started = false;
        flightState = 2;
        aBird = new Bird();
        pipes = new LinkedList<Pipe>();
      }
      else{
      }
    }
    
    if( keyPressed && key == ' '  && aBird.location.y > 0  ){
      aBird.jump();
    }
    
    // In the case that controlState is set to 0, the game is running.
    if( controlState == 0 ){
      
    }
    // In the case that controlState is set to 1, the following algorithm will play the game independent of keyboard input.
    else if( controlState == 1 ){
      if( pipes.size() > 1 ){
        if( aBird.location.y > pipes.get(0).gap + 75 && pipes.get(0).xLoc + 100 > aBird.location.x){
          aBird.jump();
        }
        else if( aBird.location.y > pipes.get(1).gap + 75 && pipes.get(0).xLoc + 100 < aBird.location.x ){
          aBird.jump();
        }
      }
      else{
         if( aBird.location.y > 500 ){
          aBird.jump();
         }
      }
    }
    // In the case that controlState is set to 2, The game will be played by the arduino
    else if( controlState == 2 ){
      
      if( flightState == 0 ){
        hovering = false;
        arduino.analogWrite(servoPin, 6);
      }
      else if( flightState == 1 ){
        hover(millis());
      }
      else if( flightState == 2 ){
        hovering = true;
        arduino.analogWrite(servoPin, 0);
      }
      
      if(pipes.size() < 3){
        flightState = 1;
      }
      else{
        for( int i = 0; i < pipes.size(); i++ ){
          if( pipes.get(i).xLoc <= 325 && pipes.get(i).xLoc > 75 ){
            int targetHeight = pipes.get(i).gap + 75;
            
            if( aBird.location.y < targetHeight - 47    ){
              flightState = 2;
            }
            else if( aBird.location.y > targetHeight + 40 ){
              flightState = 0;
            }
            else{
              flightState = 1;
            }
          }
        }
      }
      
      // Code to update the pipes
      for( int i = 0; i < pipes.size(); i++ ){
        if( pipes.get(i).xLoc + 100 <= 0){
          pipes.remove(i);
        }
        pipes.get(i).updatePipe();
        pipes.get(i).drawPipe();
      }
      
      // Code to update the bird
      aBird.updateBird();
      aBird.drawBird();
    }
  }
}